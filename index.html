<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Glitchtris 1.9 - Mobile Layout & Swipe Fix</title>
    <meta name="description" content="Experience Glitchtris, a chaotic cyberpunk twist on the classic puzzle game! Dodge glitches, clear lines, and compete for high scores.">
    <meta name="author" content="Chris Pirillo">
    <meta name="keywords" content="tetris, glitchtris, puzzle game, arcade game, javascript game, html5 game, p5js, responsive game, cyberpunk tetris, glowing blocks, mirror glitch, color glitch, board scramble, chris pirillo, pirillo.com">
    <link rel="canonical" href="https://pirillo.com/arcade/glitchtris.html">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/glitchtris.html">
    <meta property="og:title" content="Glitchtris - A Cyberpunk Puzzle Game">
    <meta property="og:description" content="Experience Glitchtris, a chaotic cyberpunk twist on the classic puzzle game! Dodge glitches, clear lines, and compete for high scores.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/glitchtris.png">
    <meta property="og:site_name" content="Pirillo.com Arcade">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://pirillo.com/arcade/glitchtris.html">
    <meta property="twitter:title" content="Glitchtris - A Cyberpunk Puzzle Game">
    <meta property="twitter:description" content="Experience Glitchtris, a chaotic cyberpunk twist on the classic puzzle game! Dodge glitches, clear lines, and compete for high scores.">
    <meta property="twitter:image" content="https://pirillo.com/arcade/images/glitchtris.png">
    <meta property="twitter:creator" content="@ChrisPirillo">
    <meta property="twitter:site" content="@ChrisPirillo">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Glitchtris",
      "url": "https://pirillo.com/arcade/glitchtris.html",
      "image": "https://pirillo.com/arcade/images/glitchtris.png",
      "description": "Experience Glitchtris, a chaotic cyberpunk twist on the classic puzzle game! Dodge glitches, clear lines, and compete for high scores.",
      "genre": ["Puzzle", "Arcade"],
      "applicationCategory": ["Game", "PuzzleGame"],
      "operatingSystem": "Web",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://chris.pirillo.com/"
      },
      "publisher": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com/"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "playMode": "SinglePlayer",
      "keywords": "tetris, glitchtris, puzzle game, arcade game, javascript game, html5 game, p5js, responsive game, cyberpunk tetris, glowing blocks, retro game"
    }
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>

    <style>
        :root {
            --font-primary: 'Orbitron', sans-serif;
            --font-secondary: 'Roboto Mono', monospace;
            
            --color-page-bg: #010003; 
            --color-ui-bg: rgba(30, 20, 60, 0.85); 
            --color-ui-border: #A000FF; 
            --color-ui-border-secondary: #0090D0; 
            --blur-intensity: 4px; 

            --color-text-primary: #F8F2FF; 
            --color-text-secondary: #D8C8F8; 
            --color-accent-primary: #A000FF; 
            --color-accent-primary-rgb: 160, 0, 255; 
            --color-accent-secondary: #0090D0; 
            --color-accent-secondary-rgb: 0, 144, 208;
            --color-accent-glow: rgba(var(--color-accent-primary-rgb), 0.8); 
            --color-accent-secondary-glow: rgba(var(--color-accent-secondary-rgb), 0.7); 
            --color-shadow: rgba(0, 0, 0, 0.85);

            --tetromino-i: '#00C0FF'; 
            --tetromino-o: '#FFEE00'; 
            --tetromino-t: '#9000E0'; 
            --tetromino-s: '#00FF00'; 
            --tetromino-z: '#FF0000'; 
            --tetromino-j: '#0000FF'; 
            --tetromino-l: '#FF5A00'; 
            --tetromino-ghost: 'rgba(248, 235, 255, 0.06)'; 

            --game-grid-bg: rgba(6, 1, 15, 0.99); 
            --grid-line-color: 'rgba(230, 110, 255, 0.12)'; 
            --scanline-color: 'rgba(230, 110, 255, 0.05)'; 
            
            --line-clear-particle-color: '#FFFFFF';
            --glitch-effect-color1: 'rgba(var(--color-accent-primary-rgb), 0.75)';
            --glitch-effect-color2: 'rgba(var(--color-accent-secondary-rgb), 0.75)';

            --border-radius: 4px; 
            --transition-speed: 0.12s; 
        }

        @keyframes dataStormParticle {
            0% { transform: translateY(-15vh) translateX(0vw) scale(0.3) rotate(var(--initialRotation)); opacity: 0; }
            10% { opacity: 0.7; } 
            90% { opacity: 0.7; }
            100% { transform: translateY(115vh) translateX(calc(var(--driftX) * 15vw)) scale(1.8) rotate(calc(var(--initialRotation) + var(--driftX) * 90deg)); opacity: 0; }
        }
        
        @keyframes panelBorderPulseCharged {
            0% { border-color: var(--color-ui-border); box-shadow: 0 0 6px var(--color-accent-glow), inset 0 0 3px rgba(var(--color-accent-primary-rgb),0.06), 0 0 1px var(--color-ui-border); }
            50% { border-color: var(--color-ui-border-secondary); box-shadow: 0 0 10px var(--color-accent-secondary-glow), inset 0 0 7px rgba(var(--color-accent-secondary-rgb),0.09), 0 0 4px var(--color-ui-border-secondary); }
            100% { border-color: var(--color-ui-border); box-shadow: 0 0 6px var(--color-accent-glow), inset 0 0 3px rgba(var(--color-accent-primary-rgb),0.06), 0 0 1px var(--color-ui-border); }
        }

        @keyframes animatedBgGrid {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; } 
        }
        
        @keyframes slowBgPan {
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }


        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        html { 
            width: 100%; height: 100%; 
        }
        body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: var(--font-secondary);
            background-color: var(--color-page-bg); 
            color: var(--color-text-primary);
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; overscroll-behavior: none; position: relative; 
        }
        
        body::before {
            content: "";
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, 
                rgba(var(--color-accent-primary-rgb), 0.03), 
                rgba(var(--color-accent-secondary-rgb), 0.03) 25%, 
                rgba(var(--color-page-bg), 0.95) 60%,
                rgba(var(--color-accent-secondary-rgb), 0.02) 85%,
                rgba(var(--color-accent-primary-rgb), 0.02)
            );
            background-size: 300% 300%; 
            animation: slowBgPan 90s ease infinite; 
            z-index: -3; 
            opacity: 0.6; 
        }
        
        .background-effects-container { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden; z-index: -2; 
        }
        .data-particle { 
            position: absolute;
            opacity: 0;
            animation-name: dataStormParticle;
            animation-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1); 
            animation-iteration-count: infinite;
            will-change: transform, opacity;
            mix-blend-mode: screen; 
            box-shadow: 0 0 2px currentColor, 0 0 4px currentColor; 
        }

        .app-container {
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            width: 100%; height: 100%;
            padding: 25px 15px; 
            gap: 15px; 
            position: relative; z-index: 1; 
        }
        
        header.app-header { display: none; }

        .game-layout {
            display: flex; justify-content: center; align-items: stretch; 
            gap: 18px; width: 100%; height: 100%;
            max-width: 96vmin; max-height: 92vh; position: relative;
        }
        
        .game-panel, .modal-content {
            background-color: var(--color-ui-bg); 
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));
            border-radius: var(--border-radius); padding: 18px; 
            border: 1.5px solid var(--color-ui-border); 
            box-shadow: 0 0 9px var(--color-accent-glow), inset 0 0 6px rgba(0,0,0,0.18), 0 0 16px var(--color-accent-secondary-glow); 
            animation: panelBorderPulseCharged 3.5s infinite ease-in-out; 
            position: relative; 
            overflow: hidden; 
        }
        
        .game-panel::before, .modal-content::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(var(--color-accent-primary-rgb), 0.03) 1px, transparent 1px), 
                linear-gradient(90deg, rgba(var(--color-accent-primary-rgb), 0.03) 1px, transparent 1px);
            background-size: 25px 25px; 
            opacity: 0.5; 
            z-index: -1; 
            animation: animatedBgGrid 10s linear infinite; 
            will-change: background-position;
        }

        .game-panel { display: flex; flex-direction: column; align-items: center; }

        .left-panel, .right-panel { width: 140px; gap: 12px; flex-shrink: 0; }
        .left-panel { order: 1; }
        .game-area-container { 
            order: 2; flex-grow: 1; 
            display: flex; justify-content: center; align-items: center; 
            min-height: 0; /* Important for flex children that might shrink */
            min-width: 0;  /* Important for flex children that might shrink */
            padding: 0; 
            position: relative; 
            touch-action: none; 
        }
        .right-panel { order: 3; }

        #game-canvas-container { 
            display: flex; justify-content: center; align-items: center;
            border: 1px solid var(--color-accent-primary); 
            border-radius: calc(var(--border-radius) - 0.5px); 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.4), 0 0 6px var(--color-accent-glow);
            background-color: var(--game-grid-bg); 
            overflow: hidden; 
            position: relative; 
        }
        
        #game-canvas-container > canvas {
            display: block; 
        }

        .info-box { 
            width: 100%; text-align: center; padding: 6px 2px;
            background: rgba(15,5,30,0.5); 
            border-radius: calc(var(--border-radius) * 0.5);
            border: 0.5px solid var(--color-ui-border-secondary); 
            position: relative; 
            z-index: 1;
        }
        
        .info-box h3 {
            font-family: var(--font-primary); font-size: 0.7rem; font-weight: 700; 
            color: var(--color-text-secondary); margin-bottom: 4px;
            text-transform: uppercase; letter-spacing: 1.4px; 
            text-shadow: 0 0 2px var(--color-accent-secondary-glow), 0 0 0.5px var(--color-accent-primary);
        }

        .info-box p, .info-box .value {
            font-family: var(--font-secondary); font-size: 1.25rem; font-weight: 700;
            color: var(--color-text-primary); min-height: 1.15em; 
            text-shadow: 0 0 4px var(--color-accent-glow), 0 0 0.8px var(--color-text-primary); 
        }
        
        .next-piece-box, .hold-piece-box {
            display: flex;
            flex-direction: column;
            align-items: center; 
        }

        #next-piece-canvas-container, #hold-piece-canvas-container {
            width: 72px; height: 56px; 
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; 
            margin-top: 4px; 
            position: relative; 
            z-index: 1;
        }
        
        .controls-section { 
            width: 100%; 
            position: relative; 
            z-index: 1;
        }
        .left-panel .controls-section { 
             margin-top: auto; 
             padding-top: 10px; 
        }
        .right-panel .controls-section {
            margin-top: auto; 
        }


        .game-button {
            font-family: var(--font-primary);
            background: linear-gradient(145deg, var(--color-accent-primary), var(--color-accent-secondary));
            color: #010003; 
            border: none; border-radius: var(--border-radius); 
            padding: 6px 9px; font-size: 0.7rem; 
            font-weight: 700; cursor: pointer;
            transition: all var(--transition-speed) ease-out;
            width: 100%; margin-top: 6px;
            box-shadow: 0 1px 7px rgba(0,0,0,0.22), inset 0 -0.5px 1.5px rgba(0,0,0,0.07),
                        0 0 4px var(--color-accent-glow), 0 0 7px var(--color-accent-secondary-glow);
            text-transform: uppercase; letter-spacing: 0.8px;
            display: block; 
            text-decoration: none; 
            text-align: center;
        }
        .game-button:hover, .game-button:focus {
            transform: translateY(-0.5px) scale(1.005);
            box-shadow: 0 2px 12px rgba(0,0,0,0.32), inset 0 -0.5px 3.5px rgba(0,0,0,0.15),
                        0 0 10px var(--color-accent-glow), 0 0 18px var(--color-accent-secondary-glow),
                        0 0 4px var(--color-text-primary); 
            outline: none;
        }
        .game-button:active { transform: translateY(0.25px) scale(0.995); box-shadow: 0 0.5px 2.5px rgba(0,0,0,0.15), inset 0 0.5px 1px rgba(0,0,0,0.18); }
        .game-button:disabled { opacity: 0.18; cursor: not-allowed; background: rgba(50,50,80,0.08); box-shadow: none; color: var(--color-text-secondary); }

        .pirillo-button {
            font-size: 0.65rem; 
            padding: 5px 7px; 
            text-transform: none; 
        }


        .modal-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(1,0,4,0.9); 
            backdrop-filter: blur(7px); -webkit-backdrop-filter: blur(7px);
            display: flex; justify-content: center; align-items: center;
            z-index: 2000; 
            opacity: 0; visibility: hidden; pointer-events: none; 
            transition: opacity var(--transition-speed) ease, visibility 0s ease var(--transition-speed); 
        }
        .modal-overlay.active { 
            opacity: 1; visibility: visible; pointer-events: auto;
            transition: opacity var(--transition-speed) ease, visibility 0s ease 0s;
        }
        .modal-content { 
            padding:20px 30px; max-width:460px; 
            box-shadow:0 0 16px var(--color-accent-glow),0 0 28px var(--color-accent-secondary-glow),inset 0 0 10px rgba(0,0,0,0.35); 
            text-align: center; border-width: 2px; 
            transform:scale(.95) translateY(16px); 
            transition:transform .16s cubic-bezier(.175,.885,.32,1.275),opacity .16s ease;
            opacity: 0; 
        }
        .modal-overlay.active .modal-content { transform:scale(1) translateY(0);opacity:1 }
        .modal-content h2 { 
            font-family: var(--font-primary); font-size:2.2rem; margin-bottom:15px; 
            text-shadow:0 0 6px var(--color-accent-glow),0 0 14px var(--color-accent-secondary-glow),0 0 1.5px var(--color-text-primary); 
            position:relative; z-index:1;
        }
        .modal-content h2.confirm-restart-title { /* Specific for confirm restart title */
            white-space: nowrap;
        }
        .modal-content h2.game-over-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 1.8rem; } 
        .modal-content p { font-size:.8rem; margin-bottom:12px; line-height:1.45; position:relative; z-index:1; }
        .modal-content .controls-list, .modal-content .game-button, .modal-content .button-container { position:relative; z-index:1; } 
        
        .controls-list {
            display: grid;
            grid-template-columns: auto 1fr; 
            gap: 8px 15px; 
            text-align: left;
            margin: 20px auto; 
            width: fit-content; 
            max-width: 100%;
        }
        .control-item {
            display: contents; 
        }
        .control-item .action-label {
            font-weight: normal; 
            color: var(--color-text-secondary); 
            font-size: 0.75rem;
            letter-spacing: 0.5px;
            padding-right: 10px; 
            white-space: nowrap;
        }
        .control-item .keys-label {
            font-family: var(--font-secondary);
            font-size: 0.75rem;
            background: rgba(var(--color-accent-primary-rgb), 0.08);
            color: var(--color-text-primary);
            padding: 3px 7px;
            border-radius: 3px;
            border: 1px solid rgba(var(--color-accent-primary-rgb), 0.25);
            text-align: center;
            white-space: nowrap;
        }
        .modal-content .touch-info { 
            margin-top: 0; 
            margin-bottom: 20px; 
        }
        .button-container { 
            text-align: center;
            margin-top: 20px; 
        }
        .button-container .game-button {
            display: inline-block; 
            width: auto; 
            margin-left: 5px;
            margin-right: 5px;
        }
        
        .mobile-controls { display: none !important; }
        
        /* --- Mobile Layout Adjustments --- */
        @media (max-width: 800px) { 
            body { font-size: 12.5px; }
            .app-container { padding: 10px 6px; gap: 8px;} /* Adjusted padding */

            .game-layout {
                flex-direction: column; /* Stack panels and game area vertically */
                align-items: center;   /* Center items horizontally */
                gap: 8px;              /* Gap between stacked items */
                max-height: none;      /* Allow layout to use full available height */
                height: 100%;          /* Occupy full app-container height */
            }

            .left-panel, .right-panel, .game-area-container {
                width: 100%;           /* Make all sections full width */
                max-width: 400px;      /* Optional: constrain max width of sections */
            }
            
            .left-panel { order: 1; flex-shrink: 0; /* Prevent shrinking */ }
            .game-area-container { 
                order: 2; 
                flex-grow: 1; /* Allow game area to take available vertical space */
                /* min-height needed for p5.js canvas height calculation */
                /* A specific height or aspect ratio might be needed if flex-grow isn't enough */
                 min-height: 250px; /* Example minimum height, adjust as needed */
            } 
            .right-panel { order: 3; flex-shrink: 0; /* Prevent shrinking */ }
            
            /* Adjust info boxes and buttons for smaller screens */
            .info-box { padding: 4px; } 
            .info-box h3 { font-size: 0.6rem; margin-bottom: 1px;}
            .info-box p, .info-box .value { font-size: 0.9rem; }
            #next-piece-canvas-container, #hold-piece-canvas-container { width: 56px; height: 42px; }
            
            .controls-section { gap: 5px; display: flex; flex-direction: column; }
            .game-button { padding: 7px 8px; font-size: 0.6rem; }
            .pirillo-button { font-size: 0.55rem; }

            .modal-content { width: 90vw; padding: 15px 10px; } 
            .modal-content h2 { font-size: 1.6rem; }
            .modal-content h2.game-over-title { font-size: 1.4rem; }
            .modal-content p { font-size: 0.75rem; } 
            .controls-list { gap: 7px 12px; margin: 18px auto; }
            .modal-content .touch-info { margin-bottom: 18px; }
            .button-container { margin-top: 18px; }
            .control-item .action-label, .control-item .keys-label { font-size: 0.7rem; padding: 2.5px 6px;}
        }

        @media (max-height: 440px) and (orientation: landscape) { 
            /* For very short landscape screens, revert to horizontal or adjust further */
            .app-container { padding: 6px 10px; } 
            /* Keep original horizontal layout for very short landscape */
            .game-layout { 
                flex-direction: row; 
                align-items: stretch;
                gap: 4px; 
            }
            .left-panel, .right-panel { width: 105px; padding: 4px; gap: 4px; flex-shrink: 0; }
            .game-area-container { 
                order: 2; flex-grow: 1; min-height: 0; /* Reset min-height */
            }
            .info-box h3 { font-size: 0.45rem;} .info-box p, .info-box .value { font-size: 0.65rem; }
        }

        *:focus-visible { outline: 1px solid var(--color-accent-secondary); outline-offset: 0.5px; box-shadow: 0 0 3px var(--color-accent-secondary-glow), 0 0 6px var(--color-accent-primary); }
        .game-button:focus-visible { outline: none; } 
    </style>
</head>
<body>
    <div class="background-effects-container" id="dataStormContainer"></div>
    <div class="app-container">
        <main class="game-layout">
            <aside class="game-panel left-panel">
                <div class="info-box score-box"><h3>Score</h3><p id="score-value" class="value">0</p></div>
                <div class="info-box level-box"><h3>Level</h3><p id="level-value" class="value">1</p></div>
                <div class="info-box lines-box"><h3>Lines</h3><p id="lines-value" class="value">0</p></div>
                <div class="controls-section">
                    <a href="https://chrispirillo.bio.link/" target="_blank" class="game-button pirillo-button">ChrisPirillo</a>
                </div>
            </aside>
            <section class="game-area-container" id="touch-area"> <div id="game-canvas-container"></div></section>
            <aside class="game-panel right-panel">
                <div class="info-box next-piece-box"><h3>Next</h3><div id="next-piece-canvas-container"></div></div>
                <div class="info-box hold-piece-box" id="hold-action-area"><h3>Hold</h3><div id="hold-piece-canvas-container"></div></div>
                <div class="controls-section">
                     <button id="pause-button" class="game-button" aria-label="Pause Game">Pause</button>
                     <button id="new-game-button" class="game-button" style="display:none;" aria-label="Restart Game">Restart</button>
                </div>
            </aside>
        </main>
    </div>

    <div class="modal-overlay" id="start-modal">
        <div class="modal-content">
            <h2>Glitchtris</h2>
            <div class="controls-list">
                <div class="control-item"><span class="action-label">Move</span><span class="keys-label">&larr; &rarr; / A D</span></div>
                <div class="control-item"><span class="action-label">Rotate</span><span class="keys-label">&uarr; / W / X</span></div>
                <div class="control-item"><span class="action-label">Soft Drop</span><span class="keys-label">&darr; / S</span></div> 
                <div class="control-item"><span class="action-label">Instant Drop</span><span class="keys-label">Spacebar</span></div>
                <div class="control-item"><span class="action-label">Hold Piece</span><span class="keys-label">Shift / C</span></div>
                <div class="control-item"><span class="action-label">Pause</span><span class="keys-label">P / Esc</span></div>
            </div>
            <p class="touch-info">Touch Controls for Mobile!</p> 
            <div class="button-container"> 
                <button id="start-game-button" class="game-button" style="padding: 14px 38px; font-size: 1.1rem;">Engage</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="pause-modal">
        <div class="modal-content">
            <h2>// Paused //</h2>
            <p>System integrity maintained. Resume sequence?</p>
            <div class="button-container">
                <button id="resume-button" class="game-button" style="padding: 14px 38px; font-size: 1.1rem;">Resume</button>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="game-over-modal">
        <div class="modal-content">
            <h2 class="game-over-title">// System Crash //</h2>
            <p>Simulation terminated. Final Score Matrix: <span id="final-score" style="font-weight: bold; color: var(--color-accent-primary);">0</span></p>
            <div class="button-container">
                <button id="restart-button-gameover" class="game-button" style="padding: 14px 38px; font-size: 1.1rem;">Re-initiate</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="restart-confirm-modal">
        <div class="modal-content">
            <h2 class="confirm-restart-title">// Confirm Restart //</h2>
            <p>Are you sure you want to restart the game? All progress will be lost.</p>
            <div class="button-container" style="display: flex; justify-content: center; gap: 10px;">
                <button id="confirm-restart-button" class="game-button" style="padding: 10px 25px; font-size: 1rem;">Restart</button>
                <button id="cancel-restart-button" class="game-button" style="padding: 10px 25px; font-size: 1rem; background: var(--color-text-secondary); color: var(--color-page-bg);">Continue</button>
            </div>
        </div>
    </div>
    
    <script>
        // --- Game Configuration ---
        const COLS = 10; const ROWS = 20; const HIDDEN_ROWS = 4; const TOTAL_ROWS = ROWS + HIDDEN_ROWS;
        const NEXT_PREVIEW_COUNT = 3; const LINE_CLEAR_PARTICLE_COUNT = 200; 
        const GLITCH_EFFECT_DURATION = 24; 
        const GRID_GLITCH_PROBABILITY = 0.15; 
        const GRID_GLITCH_LINE_COUNT = 7;   
        const GRID_GLITCH_MAX_LIFE = 22; 
        const VIEWPORT_GLITCH_PROBABILITY = 0.025; 
        const VIEWPORT_GLITCH_DURATION = 15; 
        const VIEWPORT_GLITCH_MAX_OFFSET_FACTOR = 0.7; 
        const DATA_STORM_PARTICLE_COUNT = 70; 
        const PADDING_FOR_GLITCH = 40; 
        const MIRROR_GLITCH_PROBABILITY = 0.008; 
        const MIRROR_GLITCH_MAX_LIFE = 120; 
        const TETRIS_SCRAMBLE_EFFECT_DURATION = 60; 

        const SWIPE_THRESHOLD = 40; 
        const TAP_THRESHOLD_MS = 220; 

        const LEVEL_THEMES = [ 
             { 
                name: "Neon Core Overdrive", '--color-page-bg': '#030007', '--color-ui-bg': 'rgba(25, 15, 50, 0.85)',
                '--color-ui-border': '#C800FF', '--color-ui-border-secondary': '#00B8E8',
                '--color-accent-primary': '#C800FF', '--color-accent-primary-rgb': '200, 0, 255',
                '--color-accent-secondary': '#00B8E8', '--color-accent-secondary-rgb': '0, 184, 232',
                '--color-accent-glow': 'rgba(200, 0, 255, 0.7)', '--color-accent-secondary-glow': 'rgba(0, 184, 232, 0.6)',
                '--tetromino-i': '#00E0FF', '--tetromino-o': '#FFEA1A', '--tetromino-t': '#B000E0',
                '--tetromino-s': '#18FF00', '--tetromino-z': '#FF0A00', '--tetromino-j': '#1A1AFF',
                '--tetromino-l': '#FF7800', '--game-grid-bg': 'rgba(10, 3, 22, 0.97)',
                '--grid-line-color': 'rgba(210, 90, 255, 0.18)', '--scanline-color': 'rgba(210, 90, 255, 0.07)',
                '--glitch-effect-color1': 'rgba(200, 0, 255, 0.65)', '--glitch-effect-color2': 'rgba(0, 184, 232, 0.65)'
            },
        ];
        
        const TETROMINOES = { 
            'I':{s:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],c:'--tetromino-i',o:{x:0,y:-1}},'O':{s:[[1,1],[1,1]],c:'--tetromino-o',o:{x:0,y:0}},'T':{s:[[0,1,0],[1,1,1],[0,0,0]],c:'--tetromino-t',o:{x:0,y:0}},'S':{s:[[0,1,1],[1,1,0],[0,0,0]],c:'--tetromino-s',o:{x:0,y:0}},'Z':{s:[[1,1,0],[0,1,1],[0,0,0]],c:'--tetromino-z',o:{x:0,y:0}},'J':{s:[[1,0,0],[1,1,1],[0,0,0]],c:'--tetromino-j',o:{x:0,y:0}},'L':{s:[[0,0,1],[1,1,1],[0,0,0]],c:'--tetromino-l',o:{x:0,y:0}}
        }; 
        const ALL_TETROMINO_COLOR_KEYS = Object.values(TETROMINOES).map(t => t.c);

        let board, currentPiece, nextPieces = [], heldPiece = null, canHold = true;
        let score = 0, level = 1, linesCleared = 0, gameSpeed, baseSpeed = 750, lastDropTime = 0; 
        let softDropActive = false; 
        let isPaused = false, isGameOver = false, isGameStarted = false;
        let actualBlockSize; 
        let p5InstanceCache = {};
        let lineClearParticles = [], glitchEffect = { active: false, life: 0, y: 0, height: 0 };
        let gridGlitchState = { active: false, lines: [], life: 0, maxLife: GRID_GLITCH_MAX_LIFE }; 
        let viewportGlitchState = { active: false, life: 0, xOffset: 0, yOffset: 0 };
        let mirrorGlitchState = { active: false, life: 0, maxLife: MIRROR_GLITCH_MAX_LIFE };
        let tetrisScrambleEffect = { active: false, life: 0, maxLife: TETRIS_SCRAMBLE_EFFECT_DURATION };
        let wasPausedBeforeConfirm = false; 


        const ALL_MODAL_IDS = ['start-modal', 'pause-modal', 'game-over-modal', 'restart-confirm-modal'];
        function setActiveModal(modalIdToShow) { ALL_MODAL_IDS.forEach(id => { const m=document.getElementById(id); if(m)m.classList.remove('active');}); if(modalIdToShow){const m=document.getElementById(modalIdToShow); if(m)m.classList.add('active');}}
        function getCssVariable(vN){return getComputedStyle(document.documentElement).getPropertyValue(vN).trim().replace(/^['"](.*)['"]$/,'$1');}
        
        function applyTheme(cL){
            let tI=0;if(cL>=7)tI=2;else if(cL>=4)tI=1;tI=Math.min(tI,LEVEL_THEMES.length-1);
            const sT=LEVEL_THEMES[tI];
            const rootStyle = document.documentElement.style;
            for(const[k,v]of Object.entries(sT)){
                if(k!=='name') rootStyle.setProperty(k,v);
            }
            const primaryAccentColor = getCssVariable('--color-accent-primary'); 
            if (primaryAccentColor && primaryAccentColor.startsWith('#')) {
                const r = parseInt(primaryAccentColor.slice(1, 3), 16);
                const g = parseInt(primaryAccentColor.slice(3, 5), 16);
                const b = parseInt(primaryAccentColor.slice(5, 7), 16);
                rootStyle.setProperty('--color-accent-primary-rgb', `${r}, ${g}, ${b}`);
            }
            const secondaryAccentColor = getCssVariable('--color-accent-secondary');
             if (secondaryAccentColor && secondaryAccentColor.startsWith('#')) {
                const r = parseInt(secondaryAccentColor.slice(1, 3), 16);
                const g = parseInt(secondaryAccentColor.slice(3, 5), 16);
                const b = parseInt(secondaryAccentColor.slice(5, 7), 16);
                rootStyle.setProperty('--color-accent-secondary-rgb', `${r}, ${g}, ${b}`);
            }

            if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.redraw();
            if(p5InstanceCache.nextPieceSketch?.width>0)p5InstanceCache.nextPieceSketch.redraw();
            if(p5InstanceCache.holdPieceSketch?.width>0)p5InstanceCache.holdPieceSketch.redraw();
        }

        function createEmptyBoard(){return Array.from({length:TOTAL_ROWS},()=>Array(COLS).fill(null));}
        function generatePieceBag(){let b=[...Object.keys(TETROMINOES)];for(let i=b.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[b[i],b[j]]=[b[j],b[i]];}return b;}
        let pieceBag=generatePieceBag();function getNextPieceFromBag(){if(pieceBag.length===0)pieceBag=generatePieceBag();return pieceBag.pop();}
        function createNewPiece(k){const d=TETROMINOES[k];const s=d.s.map(r=>r.slice());return{x:Math.floor(COLS/2)-Math.ceil(s[0].length/2)+(d.o.x||0),y:(d.o.y||0),shape:s,colorKey:d.c,key:k};}
        
        function rotateMatrix(m){const N=m.length,nM=Array.from({length:N},()=>Array(N).fill(0));for(let r=0;r<N;r++)for(let c=0;c<N;c++)nM[c][N-1-r]=m[r][c];return nM;}
        function attemptRotation(){if(isPaused||isGameOver||!isGameStarted||!currentPiece)return;const oS=currentPiece.shape.map(r=>r.slice()),oX=currentPiece.x,oY=currentPiece.y;currentPiece.shape=rotateMatrix(currentPiece.shape);const kTs=[[0,0],[-1,0],[1,0],[0,-1],[-1,-1],[1,-1]];if(currentPiece.key==='I')kTs.push([-2,0],[2,0],[0,-2],[-1,1],[2,1],[-1,-2],[2,-2]);else if(currentPiece.key==='O'){currentPiece.shape=oS;return;}for(const[kX,kY]of kTs){if(!checkCollision(currentPiece,board,kX,kY)){currentPiece.x+=kX;currentPiece.y+=kY;if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.redraw();return;}}currentPiece.shape=oS;currentPiece.x=oX;currentPiece.y=oY;}

        function checkCollision(pc,bS,oX=0,oY=0){if(!pc?.shape)return true;const{x,y,shape}=pc;for(let r=0;r<shape.length;r++)for(let c=0;c<shape[r].length;c++)if(shape[r][c]){const bX=x+c+oX,bY=y+r+oY;if(bX<0||bX>=COLS||bY>=TOTAL_ROWS||(bY>=0&&bS[bY]?.[bX]))return true;}return false;}
        function mergePieceToBoard(){if(!currentPiece?.shape)return;currentPiece.shape.forEach((rw,r)=>{rw.forEach((cl,c)=>{if(cl){const bX=currentPiece.x+c,bY=currentPiece.y+r;if(bY>=0&&bY<TOTAL_ROWS&&bX>=0&&bX<COLS)board[bY][bX]={baseColorKey:currentPiece.colorKey};}});});}
        function triggerLineClearEffect(cRs){const p=p5InstanceCache.mainSketch;if(!p||!actualBlockSize||cRs.length===0)return;glitchEffect.active=true;glitchEffect.life=GLITCH_EFFECT_DURATION;glitchEffect.y=cRs[0]*actualBlockSize;glitchEffect.height=cRs.length*actualBlockSize;const gameAreaWidth = COLS * actualBlockSize; cRs.forEach(rI=>{const yP=rI*actualBlockSize+actualBlockSize/2;for(let i=0;i<LINE_CLEAR_PARTICLE_COUNT/cRs.length;i++){const a=p.random(p.TWO_PI),s=p.random(8,16);lineClearParticles.push({x:p.random(gameAreaWidth),y:yP+p.random(-actualBlockSize*2.2,actualBlockSize*2.2),vx:p.cos(a)*s,vy:p.sin(a)*s-p.random(3.5,8),alpha:255,size:p.random(8,22),color:p.color(getCssVariable('--line-clear-particle-color'))});}}); }
        
        function scrambleBoard() {
            const landedBlocks = [];
            for (let r = 0; r < TOTAL_ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        landedBlocks.push({ r, c, data: board[r][c] });
                    }
                }
            }
            if (landedBlocks.length === 0) return;
            const blockDataToScramble = landedBlocks.map(b => b.data);
            for (let i = blockDataToScramble.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [blockDataToScramble[i], blockDataToScramble[j]] = [blockDataToScramble[j], blockDataToScramble[i]];
            }
            landedBlocks.forEach((block, index) => {
                board[block.r][block.c] = blockDataToScramble[index];
            });
            tetrisScrambleEffect.active = true;
            tetrisScrambleEffect.life = tetrisScrambleEffect.maxLife;
        }

        function clearLines(){
            let cC=0,cVIdx=[];
            for(let r=TOTAL_ROWS-1;r>=0;r--){
                if(board[r].every(c=>c!==null)){
                    cC++;cVIdx.unshift(r-HIDDEN_ROWS);board.splice(r,1);board.unshift(Array(COLS).fill(null));r++;
                }
            }
            if(cC>0){
                triggerLineClearEffect(cVIdx);linesCleared+=cC;
                let bP=(cC===1)?120:(cC===2)?300:(cC===3)?800:(cC>=4)?3000:0;score+=bP*level;
                scrambleBoard(); 
                const oL=level;level=Math.floor(linesCleared/6)+1;
                if(level>oL)applyTheme(level);updateGameSpeed();updateUI();
            }
        }

        function spawnNewPiece(){while(nextPieces.length<NEXT_PREVIEW_COUNT+1)nextPieces.push(createNewPiece(getNextPieceFromBag()));currentPiece=nextPieces.shift();if(!currentPiece||checkCollision(currentPiece,board)){isGameOver=true;if(p5InstanceCache.mainSketch)p5InstanceCache.mainSketch.noLoop();document.getElementById('final-score').textContent=score;setActiveModal('game-over-modal');const pB=document.getElementById('pause-button');if(pB)pB.disabled=true;return;}canHold=true;if(p5InstanceCache.nextPieceSketch?.width>0)p5InstanceCache.nextPieceSketch.redraw();}
        function updateGameSpeed(){gameSpeed=Math.max(35,baseSpeed-(level-1)*75);}
        function updateUI(){document.getElementById('score-value').textContent=score;document.getElementById('level-value').textContent=level;document.getElementById('lines-value').textContent=linesCleared;}
        function movePiece(dX,dY){if(isPaused||isGameOver||!isGameStarted||!currentPiece)return false; const moveDX = mirrorGlitchState.active ? -dX : dX; if(!checkCollision(currentPiece,board,moveDX,dY)){currentPiece.x+=moveDX;currentPiece.y+=dY;if(dY>0&&p5InstanceCache.mainSketch?.millis&&!softDropActive)lastDropTime=p5InstanceCache.mainSketch.millis();if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.redraw();return true;}return false;}
        
        function hardDrop(){if(isPaused||isGameOver||!isGameStarted||!currentPiece)return;let dD=0;while(!checkCollision(currentPiece,board,0,1)){currentPiece.y++;dD++;}score+=dD*3;lockPiece();}
        
        function getGhostPieceY(){if(!currentPiece)return 0;let gY=currentPiece.y;while(!checkCollision({...currentPiece,y:gY+1},board))gY++;return gY;}
        function lockPiece(){if(isGameOver)return;mergePieceToBoard();clearLines();spawnNewPiece();if(!isGameOver&&p5InstanceCache.mainSketch?.millis)lastDropTime=p5InstanceCache.mainSketch.millis();if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.redraw();}
        function holdCurrentPiece(){if(isPaused||isGameOver||!isGameStarted||!canHold||!currentPiece)return;const pHK=heldPiece?heldPiece.key:null;heldPiece=createNewPiece(currentPiece.key);if(pHK)currentPiece=createNewPiece(pHK);else{spawnNewPiece();if(isGameOver)return;}if(checkCollision(currentPiece,board)){isGameOver=true;if(p5InstanceCache.mainSketch)p5InstanceCache.mainSketch.noLoop();document.getElementById('final-score').textContent=score;setActiveModal('game-over-modal');const pB=document.getElementById('pause-button');if(pB)pB.disabled=true;return;}canHold=false;if(p5InstanceCache.holdPieceSketch?.width>0)p5InstanceCache.holdPieceSketch.redraw();if(p5InstanceCache.nextPieceSketch?.width>0)p5InstanceCache.nextPieceSketch.redraw();if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.redraw();}
        function resetGame(){board=createEmptyBoard();pieceBag=generatePieceBag();nextPieces=[];for(let i=0;i<NEXT_PREVIEW_COUNT+1;i++)nextPieces.push(createNewPiece(getNextPieceFromBag()));isGameOver=false;isPaused=false;softDropActive=false;lineClearParticles=[];glitchEffect.active=false;gridGlitchState.active=false;viewportGlitchState.active=false; mirrorGlitchState.active = false; mirrorGlitchState.life = 0; tetrisScrambleEffect.active = false; tetrisScrambleEffect.life = 0; level=1;applyTheme(level);spawnNewPiece();if(isGameOver)return;heldPiece=null;canHold=true;score=0;linesCleared=0;updateGameSpeed();updateUI();if(p5InstanceCache.mainSketch?.millis&&p5InstanceCache.mainSketch.width>0){lastDropTime=p5InstanceCache.mainSketch.millis();p5InstanceCache.mainSketch.loop();}else if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.loop();if(p5InstanceCache.nextPieceSketch?.width>0)p5InstanceCache.nextPieceSketch.redraw();if(p5InstanceCache.holdPieceSketch?.width>0)p5InstanceCache.holdPieceSketch.redraw();const pB=document.getElementById('pause-button');if(pB){pB.textContent='Pause';pB.disabled=false;}const ngB=document.getElementById('new-game-button');if(ngB)ngB.style.display='inline-block';setActiveModal(null);}
        function togglePause(){if(isGameOver||!isGameStarted)return;isPaused=!isPaused;const pB=document.getElementById('pause-button');if(isPaused){if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.noLoop();if(pB)pB.textContent='Resume';setActiveModal('pause-modal');}else{if(p5InstanceCache.mainSketch?.millis&&p5InstanceCache.mainSketch.width>0){lastDropTime=p5InstanceCache.mainSketch.millis();p5InstanceCache.mainSketch.loop();}else if(p5InstanceCache.mainSketch?.width>0)p5InstanceCache.mainSketch.loop();if(pB)pB.textContent='Pause';setActiveModal(null);}}
        function initGame(){isGameStarted=true;if(!p5InstanceCache.mainSketch?.canvas)setupP5Sketches();resetGame();setActiveModal(null);const pB=document.getElementById('pause-button');if(pB)pB.style.display='inline-block';const ngB=document.getElementById('new-game-button');if(ngB)ngB.style.display='inline-block';}
        
        function handleRestartRequest() {
            if (!isGameStarted || isGameOver) { 
                 setActiveModal('restart-confirm-modal');
                 return;
            }
            wasPausedBeforeConfirm = isPaused;
            if (!isPaused && p5InstanceCache.mainSketch?.width > 0) {
                p5InstanceCache.mainSketch.noLoop(); 
            }
            setActiveModal('restart-confirm-modal');
        }

        const mainGameSketch = (p) => {
            p.windowResized = () => {
                const cPC = document.getElementById('game-canvas-container'); 
                const aC = document.querySelector('.game-area-container'); 
                if (!cPC || !aC) {
                    console.error("Glitchtris: Canvas containers not found for resize.");
                    return;
                }
                // Ensure parent container (aC) has valid dimensions before calculations
                if (aC.clientWidth <= 0 || aC.clientHeight <= 0) {
                    console.warn("Glitchtris: Game area container has zero dimensions. Canvas might not be visible.", aC.clientWidth, aC.clientHeight);
                    // Fallback or wait for layout if necessary. For now, proceed with caution.
                    // actualBlockSize will become 1 due to Math.max(1, ...) if dimensions are 0.
                }

                let bSFW = aC.clientWidth / COLS;
                let bSFH = aC.clientHeight / ROWS; 
                actualBlockSize = Math.floor(Math.min(bSFW, bSFH));
                actualBlockSize = Math.max(1, actualBlockSize); // Ensure blocksize is at least 1

                const logicalWidth = COLS * actualBlockSize;
                const logicalHeight = ROWS * actualBlockSize;
                
                if (logicalWidth <=0 || logicalHeight <=0) {
                    console.error("Glitchtris: Calculated logical canvas size is invalid. Game may not display correctly.");
                    // This case should ideally not be reached if actualBlockSize is at least 1.
                    return;
                }

                cPC.style.width = logicalWidth + 'px';
                cPC.style.height = logicalHeight + 'px';
                
                const paddedCanvasWidth = logicalWidth + 2 * PADDING_FOR_GLITCH;
                const paddedCanvasHeight = logicalHeight + 2 * PADDING_FOR_GLITCH;

                if (p.canvas && paddedCanvasWidth > 0 && paddedCanvasHeight > 0) {
                    try {
                        p.resizeCanvas(paddedCanvasWidth, paddedCanvasHeight);
                    } catch (e) {
                        console.error("Error resizing p5 canvas:", e);
                    }
                } else if (!p.canvas) {
                     console.warn("Glitchtris: p.canvas not defined during windowResized.");
                }
                p.redraw();
            }

            p.setup = () => {
                const cPC = document.getElementById('game-canvas-container');
                if (!cPC) { console.error("Glitchtris: Main canvas parent container not found!"); return; }
                let cnv;
                try {
                    cnv = p.createCanvas(100 + 2 * PADDING_FOR_GLITCH, 200 + 2 * PADDING_FOR_GLITCH); 
                    cnv.parent(cPC);
                } catch (e) {
                    console.error("Error creating p5 canvas:", e);
                    return;
                }
                p.windowResized(); // Initial sizing
                p.frameRate(30);
                if (!isGameStarted) { updateUI(); p.redraw(); p.noLoop(); } 
                else if (isPaused || isGameOver) { p.redraw(); p.noLoop(); } 
                else p.loop();
            };
            
            function drawGameScanlines(p) {
                const sC = p.color(getCssVariable('--scanline-color'));
                sC.setAlpha(20); 
                p.stroke(sC);
                p.strokeWeight(0.7);
                const gameAreaWidth = COLS * actualBlockSize; 
                const gameAreaHeight = ROWS * actualBlockSize; 
                for (let i = 0; i < gameAreaHeight; i += 2.5) p.line(0, i, gameAreaWidth, i);
            }

            function drawGlitchEffect(p){if(glitchEffect.active&&glitchEffect.life>0){const x=0,y=glitchEffect.y,w=COLS*actualBlockSize,h=glitchEffect.height;const intensity=p.map(glitchEffect.life,GLITCH_EFFECT_DURATION,0,1.6,0.35);for(let i=0;i<18;i++){const sY=y+p.random(h),sH=p.random(actualBlockSize*0.4,actualBlockSize*3.2)*intensity;const oX=p.random(-actualBlockSize*2.5,actualBlockSize*2.5)*intensity;p.blendMode(p.ADD);p.fill(p.random()>.5?p.color(getCssVariable('--glitch-effect-color1')):p.color(getCssVariable('--glitch-effect-color2')));p.noStroke();p.rect(x+oX,sY-sH/2,w,sH);}p.blendMode(p.BLEND);glitchEffect.life--;if(glitchEffect.life<=0)glitchEffect.active=false;}}
            function drawLineClearParticles(p){const pC=p.color(getCssVariable('--line-clear-particle-color'));for(let i=lineClearParticles.length-1;i>=0;i--){let pt=lineClearParticles[i];p.noStroke();p.blendMode(p.ADD);pC.setAlpha(pt.alpha);p.fill(pC);p.push();p.translate(pt.x,pt.y);p.rotate(pt.vx*0.18);p.rect(-pt.size*actualBlockSize/220,-pt.size*actualBlockSize/220,pt.size*actualBlockSize/110,pt.size*actualBlockSize/110);p.pop();p.blendMode(p.BLEND);pt.x+=pt.vx;pt.y+=pt.vy;pt.vy+=0.22;pt.alpha-=5;pt.size*=.95;if(pt.alpha<=0||pt.size<.5)lineClearParticles.splice(i,1);}}
            
            p.draw = () => {
                if (!p.width || !p.height || !actualBlockSize || actualBlockSize <= 0) {
                    // console.warn("Glitchtris: Draw call skipped due to invalid canvas/block size.");
                    return;
                }

                let vGX = 0, vGY = 0;
                if (viewportGlitchState.active) {
                    vGX = viewportGlitchState.xOffset; vGY = viewportGlitchState.yOffset;
                    viewportGlitchState.life--;
                    if (viewportGlitchState.life <= 0) viewportGlitchState.active = false;
                } else if (p.random() < VIEWPORT_GLITCH_PROBABILITY && !isPaused && !isGameOver && isGameStarted) {
                    viewportGlitchState.active = true; viewportGlitchState.life = VIEWPORT_GLITCH_DURATION;
                    let gA = actualBlockSize * p.random(0.25, VIEWPORT_GLITCH_MAX_OFFSET_FACTOR * 1.8);
                    viewportGlitchState.xOffset = (p.random() > .5 ? 1 : -1) * gA;
                    viewportGlitchState.yOffset = (p.random() > .5 ? 1 : -1) * gA;
                }

                if (gridGlitchState.active) {
                    gridGlitchState.life--; if (gridGlitchState.life <= 0) gridGlitchState.active = false;
                } else if (p.random() < GRID_GLITCH_PROBABILITY && !isPaused && !isGameOver && isGameStarted) {
                    gridGlitchState.active = true; gridGlitchState.life = GRID_GLITCH_MAX_LIFE; gridGlitchState.lines = [];
                    for (let i = 0; i < GRID_GLITCH_LINE_COUNT; i++) gridGlitchState.lines.push({ type: p.random() > .5 ? 'h' : 'v', index: p.random() > .5 ? p.floor(p.random(COLS + 1)) : p.floor(p.random(ROWS + 1)), offset: p.random(-actualBlockSize * 0.4, actualBlockSize * 0.4), lengthFactor: p.random(0.03, 0.6) });
                }
                
                if (mirrorGlitchState.active) {
                    mirrorGlitchState.life--;
                    if (mirrorGlitchState.life <= 0) mirrorGlitchState.active = false;
                } else if (p.random() < MIRROR_GLITCH_PROBABILITY && !isPaused && !isGameOver && isGameStarted && !viewportGlitchState.active && !gridGlitchState.active) {
                    mirrorGlitchState.active = true;
                    mirrorGlitchState.life = mirrorGlitchState.maxLife;
                }
                
                if (tetrisScrambleEffect.active) {
                    tetrisScrambleEffect.life--;
                    if (tetrisScrambleEffect.life <= 0) tetrisScrambleEffect.active = false;
                }

                p.background(p.color(getCssVariable('--game-grid-bg')));
                p.push(); 
                p.translate(vGX, vGY);
                p.push(); 
                p.translate(PADDING_FOR_GLITCH, PADDING_FOR_GLITCH);

                drawGameScanlines(p); 

                if (!isGameStarted || (isPaused && !currentPiece) || (isGameOver && !currentPiece)) {
                    if (board) { drawBoardGrid(p); drawLandedPieces(p); }
                    drawLineClearParticles(p); drawGlitchEffect(p);
                } else { 
                    if (!isPaused && !isGameOver && currentPiece) {
                        const autoDropSpeed = softDropActive ? Math.min(gameSpeed, 50) : gameSpeed; 
                        if (p.millis() - lastDropTime > autoDropSpeed) {
                            if (!checkCollision(currentPiece, board, 0, 1)) {
                                currentPiece.y++;
                            } else {
                                lockPiece();
                                if (isGameOver) { 
                                    drawBoardGrid(p); drawLandedPieces(p);
                                    drawLineClearParticles(p); drawGlitchEffect(p);
                                    if (p5InstanceCache.mainSketch) p5InstanceCache.mainSketch.noLoop();
                                    p.pop(); p.pop(); 
                                    return; 
                                }
                            }
                            lastDropTime = p.millis();
                        }
                    }
                    drawBoardGrid(p); drawLandedPieces(p);
                    if (currentPiece) { drawGhostPiece(p); drawCurrentPiece(p); }
                    drawLineClearParticles(p); drawGlitchEffect(p);
                }
                if (tetrisScrambleEffect.active) { 
                    p.fill(255, 255, 255, p.map(tetrisScrambleEffect.life, tetrisScrambleEffect.maxLife, 0, 100, 0));
                    p.rect(0,0, COLS * actualBlockSize, ROWS * actualBlockSize);
                }
                p.pop(); 
                p.pop(); 
            };

            function drawBoardGrid(p){
                if(!actualBlockSize || actualBlockSize <= 0) return;
                const gC=p.color(getCssVariable('--grid-line-color'));
                gC.setAlpha(230);p.stroke(gC);p.strokeWeight(0.5);
                const gameAreaWidth=COLS*actualBlockSize,gameAreaHeight=ROWS*actualBlockSize;
                
                for(let i=0;i<=COLS;i++) { 
                    const displayI = mirrorGlitchState.active ? (COLS - i) : i;
                    p.line(displayI*actualBlockSize,0,displayI*actualBlockSize,gameAreaHeight);
                }
                for(let i=0;i<=ROWS;i++) { 
                    p.line(0,i*actualBlockSize,gameAreaWidth,i*actualBlockSize);
                }

                if(gridGlitchState.active){
                    p.strokeWeight(p.random(1,3.2));
                    const c1=p.color(getCssVariable('--glitch-effect-color1')),c2=p.color(getCssVariable('--glitch-effect-color2'));
                    gridGlitchState.lines.forEach(l=>{
                        p.stroke(p.random()>.5?c1:c2);
                        let x1,y1,x2,y2;
                        if(l.type==='h'){
                            y1=y2=l.index*actualBlockSize+l.offset;
                            let sX=p.random(gameAreaWidth*(1-l.lengthFactor));
                            x1=sX;x2=sX+gameAreaWidth*l.lengthFactor*p.random(0.2,1.3);
                            if(mirrorGlitchState.active) { x1 = gameAreaWidth - x1; x2 = gameAreaWidth - x2; }
                            if(y1>0&&y1<gameAreaHeight)p.line(x1,y1,x2,y2);
                        } else {
                            x1=x2=l.index*actualBlockSize+l.offset;
                            let sY=p.random(gameAreaHeight*(1-l.lengthFactor));
                            y1=sY;y2=sY+gameAreaHeight*l.lengthFactor*p.random(0.2,1.3);
                            if(mirrorGlitchState.active) { x1 = gameAreaWidth - x1; x2 = gameAreaWidth - x2; }
                            if(x1>0&&x1<gameAreaWidth)p.line(x1,y1,x2,y2);
                        }
                    });
                }
            }

            function drawLandedPieces(p){if(!board||!actualBlockSize || actualBlockSize <= 0)return;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cd=board[r+HIDDEN_ROWS]?.[c];if(cd?.baseColorKey)drawBlock(p,c,r,cd.baseColorKey,true);}}
            function drawGhostPiece(p){if(!currentPiece||isGameOver||!actualBlockSize || actualBlockSize <= 0)return;const gY=getGhostPieceY(),gC=p.color(getCssVariable('--tetromino-ghost'));gC.setAlpha(120);currentPiece.shape.forEach((rw,rS)=>{rw.forEach((cl,cS)=>{if(cl){const dY=gY+rS-HIDDEN_ROWS;if(dY>=0){const displayX = mirrorGlitchState.active ? (COLS - 1 - (currentPiece.x + cS)) : (currentPiece.x + cS); p.fill(gC);p.stroke(255,255,255,45);p.strokeWeight(0.3);p.rect(displayX*actualBlockSize+.3,dY*actualBlockSize+.3,actualBlockSize-.6,actualBlockSize-.6,actualBlockSize*.06);}}});});}
            function drawCurrentPiece(p){if(!currentPiece||(isGameOver&&checkCollision(currentPiece,board))||!actualBlockSize || actualBlockSize <= 0)return;currentPiece.shape.forEach((rw,rS)=>{rw.forEach((cl,cS)=>{if(cl){const dY=currentPiece.y+rS-HIDDEN_ROWS;if(dY>=0)drawBlock(p,currentPiece.x+cS,dY,currentPiece.colorKey,false);}});});}
            
            function drawBlock(p,xG,yG,cK,iL){ 
                if(!actualBlockSize || actualBlockSize <= 0)return;
                const finalXG = mirrorGlitchState.active ? (COLS - 1 - xG) : xG; 
                const bC=p.color(getCssVariable(cK)),bX=finalXG*actualBlockSize,bY=yG*actualBlockSize;
                const cR=actualBlockSize*.08,bW=actualBlockSize*.035;
                
                if(!iL){ 
                    p.drawingContext.shadowBlur = actualBlockSize * 0.45; 
                    p.drawingContext.shadowColor = bC.toString();
                }
                p.noStroke();
                p.fill(bC);
                p.rect(bX,bY,actualBlockSize,actualBlockSize,cR);
                p.drawingContext.shadowBlur=0; 

                let pF=(p.sin(p.frameCount*.25+finalXG+yG*.8)+1)/2; 
                
                let dA=iL?p.map(pF,0,1,30,100):p.map(pF,0,1,120,220); 
                let hC=p.color(p.red(bC)+120,p.green(bC)+120,p.blue(bC)+120,dA); 
                p.fill(hC);
                p.rect(bX+bW,bY+bW,actualBlockSize-2*bW,actualBlockSize-2*bW,cR>bW?cR-bW*.9:0);
                
                p.fill(255,255,255, iL ? 25 : 70); 
                p.beginShape();
                p.vertex(bX+bW,bY+bW);
                p.vertex(bX+actualBlockSize-bW,bY+bW);
                p.vertex(bX+actualBlockSize-bW*3,bY+bW*4); 
                p.vertex(bX+bW*3,bY+bW*4);
                p.endShape(p.CLOSE);

                if(!iL){ 
                    p.stroke(p.red(bC)*1.6,p.green(bC)*1.6,p.blue(bC)*1.6, 35); 
                    p.strokeWeight(Math.max(.2,actualBlockSize*.01)); 
                    for(let i=0;i<3;i++){ 
                        let yO=(i*0.33 + pF*0.1 - 0.05)*actualBlockSize; 
                        p.line(bX+bW,bY+yO,bX+actualBlockSize-bW,bY+yO);
                    }
                }
            }
        };
        
        const previewPieceSketch = (p, pieceProviderFn, containerId) => { 
            let previewBlockSize; 
            p.setup = () => { 
                const cc=document.getElementById(containerId);
                if(!cc)return;
                // Ensure clientWidth/Height are positive before calculating previewBlockSize
                const containerWidth = cc.clientWidth > 0 ? cc.clientWidth : 72; // Fallback width
                const containerHeight = cc.clientHeight > 0 ? cc.clientHeight : 56; // Fallback height

                previewBlockSize = Math.max(1, Math.floor(Math.min(containerWidth / 4.2, containerHeight / 2.8, 22))); 
                let cnv = p.createCanvas(containerWidth, containerHeight); 
                cnv.parent(containerId);
                p.noLoop();
            };
            p.draw = () => { 
                if(!p.width||!p.height || !previewBlockSize || previewBlockSize <=0)return;
                p.clear();
                const pTD=pieceProviderFn();
                if(pTD?.shape){
                    const{shape,colorKey}=pTD;
                    let mR=shape.length,xR=-1,mC=shape[0].length,xC=-1,hB=false;
                    for(let r=0;r<shape.length;r++)for(let c=0;c<shape[r].length;c++)if(shape[r][c]){hB=true;mR=Math.min(mR,r);xR=Math.max(xR,r);mC=Math.min(mC,c);xC=Math.max(xC,c);}
                    if(!hB)return;
                    const sW=(xC-mC+1),sH=(xR-mR+1);
                    const oX=(p.width-sW*previewBlockSize)/2-(mC*previewBlockSize);
                    const oY=(p.height-sH*previewBlockSize)/2-(mR*previewBlockSize);
                    const bC=p.color(getCssVariable(colorKey));
                    for(let r=0;r<shape.length;r++)for(let c=0;c<shape[r].length;c++)if(shape[r][c]){
                        const x=oX+c*previewBlockSize,y=oY+r*previewBlockSize;
                        p.fill(bC);p.noStroke();p.rect(x,y,previewBlockSize,previewBlockSize,previewBlockSize*.12);
                        let hC=p.color(p.red(bC)+90,p.green(bC)+90,p.blue(bC)+90,230);
                        p.fill(hC);p.rect(x+previewBlockSize*.07,y+previewBlockSize*.07,previewBlockSize*.86,previewBlockSize*.86,previewBlockSize*.08);
                    }
                }
            };
        };

        function createDataStormParticles(){
            const cont=document.getElementById('dataStormContainer');
            if(!cont)return;
            cont.innerHTML = ''; 
            for(let i=0;i<DATA_STORM_PARTICLE_COUNT;i++){
                const particle = document.createElement('div');
                particle.classList.add('data-particle');
                
                const size = Math.floor(5 + Math.random() * 5); 
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                const randomColorKey = ALL_TETROMINO_COLOR_KEYS[Math.floor(Math.random() * ALL_TETROMINO_COLOR_KEYS.length)];
                particle.style.backgroundColor = getCssVariable(randomColorKey);
                
                particle.style.left = `${Math.random()*100}vw`;
                const initialRotation = Math.random() * 360;
                particle.style.setProperty('--initialRotation', `${initialRotation}deg`);
                particle.style.setProperty('--driftX', (Math.random() - 0.5) * 2); 
                
                particle.style.animationDuration = `${2.5+Math.random()*4}s`; 
                particle.style.animationDelay = `-${Math.random()*7}s`;
                cont.appendChild(particle);
            }
        }
        
        function setupP5Sketches() { 
            if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',setupP5Sketches);return;}
            if(p5InstanceCache.mainSketch)p5InstanceCache.mainSketch.remove();if(p5InstanceCache.nextPieceSketch)p5InstanceCache.nextPieceSketch.remove();if(p5InstanceCache.holdPieceSketch)p5InstanceCache.holdPieceSketch.remove();
            
            p5InstanceCache.mainSketch=new p5(mainGameSketch);
            p5InstanceCache.nextPieceSketch=new p5((p)=>previewPieceSketch(p,()=>nextPieces[0],'next-piece-canvas-container'));
            p5InstanceCache.holdPieceSketch=new p5((p)=>previewPieceSketch(p,()=>heldPiece,'hold-piece-canvas-container'));
            
            setTimeout(()=>{ // Delay to ensure containers have dimensions
                if(p5InstanceCache.mainSketch?.canvas){
                    p5InstanceCache.mainSketch.windowResized(); // Re-run resize after a short delay
                    if(!isGameStarted) p5InstanceCache.mainSketch.noLoop();
                }
                const nC=document.getElementById('next-piece-canvas-container');
                if(p5InstanceCache.nextPieceSketch?.canvas&&nC?.clientWidth>0){
                    p5InstanceCache.nextPieceSketch.resizeCanvas(nC.clientWidth,nC.clientHeight); 
                    p5InstanceCache.nextPieceSketch.setup(); // Re-run setup for preview
                    p5InstanceCache.nextPieceSketch.redraw();
                }
                const hC=document.getElementById('hold-piece-canvas-container');
                if(p5InstanceCache.holdPieceSketch?.canvas&&hC?.clientWidth>0){
                    p5InstanceCache.holdPieceSketch.resizeCanvas(hC.clientWidth,hC.clientHeight); 
                    p5InstanceCache.holdPieceSketch.setup(); // Re-run setup for preview
                    p5InstanceCache.holdPieceSketch.redraw();
                }
            }, 150); 
        }
        
        document.addEventListener('DOMContentLoaded', () => { 
            createDataStormParticles(); 
            board=createEmptyBoard();pieceBag=generatePieceBag();nextPieces=[];for(let i=0;i<NEXT_PREVIEW_COUNT+1;i++)nextPieces.push(createNewPiece(getNextPieceFromBag()));
            applyTheme(level); 
            updateUI();
            const sm=document.getElementById('start-modal'); if(sm)setActiveModal('start-modal'); else console.warn("Start modal not found");
            setupP5Sketches();

            const touchArea = document.getElementById('touch-area');
            const holdArea = document.getElementById('hold-action-area');
            let touchStartX = 0, touchStartY = 0, touchStartTime = 0;

            if (touchArea) {
                touchArea.addEventListener('touchstart', (e) => {
                    if (isPaused || isGameOver || !isGameStarted) return;
                    // e.preventDefault(); // Only preventDefault if a game action will occur.
                    if (e.touches.length === 1) { // Handle single touch
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        touchStartTime = Date.now();
                    }
                }, { passive: true }); // passive: true if not always preventing default

                touchArea.addEventListener('touchmove', (e) => {
                    if (isPaused || isGameOver || !isGameStarted) return;
                    // e.preventDefault(); // Prevent scroll only if a swipe is being processed
                }, { passive: true }); // passive: true if not always preventing default

                touchArea.addEventListener('touchend', (e) => {
                    if (isPaused || isGameOver || !isGameStarted || e.changedTouches.length === 0) return;
                    // No e.preventDefault() here unless an action is taken
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const touchEndTime = Date.now();
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    const deltaTime = touchEndTime - touchStartTime;
                    const absDeltaX = Math.abs(deltaX);
                    const absDeltaY = Math.abs(deltaY);

                    // Check if it's a significant gesture before preventing default
                    let actionTaken = false;

                    if (deltaTime < TAP_THRESHOLD_MS && absDeltaX < SWIPE_THRESHOLD / 1.5 && absDeltaY < SWIPE_THRESHOLD / 1.5) { 
                        attemptRotation(); 
                        actionTaken = true;
                    } else if (absDeltaX > absDeltaY && absDeltaX > SWIPE_THRESHOLD) { 
                        if (deltaX > 0) movePiece(1, 0); 
                        else movePiece(-1, 0); 
                        actionTaken = true;
                    } else if (absDeltaY > absDeltaX && absDeltaY > SWIPE_THRESHOLD) { 
                        if (deltaY > 0) { // Swipe Down
                           // softDropActive = true; // REMOVED: This was causing continuous drop
                           if(currentPiece && !checkCollision(currentPiece, board, 0, 1)) {
                              currentPiece.y++; score+=1; 
                              if(p5InstanceCache.mainSketch?.millis) lastDropTime = p5InstanceCache.mainSketch.millis();
                              if(p5InstanceCache.mainSketch?.width > 0) p5InstanceCache.mainSketch.redraw();
                           } else if (currentPiece && !isGameOver) {
                              lockPiece();
                           }
                           actionTaken = true;
                        }
                        // No swipe up action defined here
                    }
                    if (actionTaken && e.cancelable) { // Only preventDefault if an action was taken and event is cancelable
                        e.preventDefault();
                    }
                }, { passive: false }); // Keep false if preventDefault might be called
            } else { console.warn("Touch area 'touch-area' not found."); }
            
            if (holdArea) {
                holdArea.addEventListener('click', holdCurrentPiece); 
                holdArea.addEventListener('touchend', (e) => { 
                     if (e.cancelable) e.preventDefault(); // Prevent default if an action is taken
                     holdCurrentPiece();
                }, {passive: false}); // Keep false if preventDefault might be called
            } else { console.warn("Hold action area 'hold-action-area' not found.");}


            document.addEventListener('keydown',(e)=>{
                if(!isGameStarted && e.key!=='Enter' && e.key!==' ') return;
                if(document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='TEXTAREA')) {
                    if(e.key!=='Escape') return;
                } 
                if(document.getElementById('restart-confirm-modal')?.classList.contains('active') && e.key !== 'Escape' && e.key !== 'Enter') return; 
                if(isPaused && e.key.toLowerCase()!=='p' && e.key!=='Escape' && !document.getElementById('pause-modal')?.classList.contains('active')) return; // Allow P/Esc if pause modal is not active (e.g. to open it)
                
                const relevantKeys = ['arrowleft','arrowright','arrowdown','arrowup',' ','shift','c','x','p','escape','a','s','d','w','enter'];
                if(relevantKeys.includes(e.key.toLowerCase())) {
                    if (e.key.toLowerCase() === 'escape' && document.getElementById('start-modal')?.classList.contains('active')) {
                        // Do not prevent default for Escape on start modal, allow it to potentially close if browser handles it
                    } else {
                        e.preventDefault();
                    }
                }
            
                switch(e.key.toLowerCase()){
                    case'arrowleft':case'a':if(!isPaused)movePiece(-1,0);break;
                    case'arrowright':case'd':if(!isPaused)movePiece(1,0);break;
                    case'arrowdown':case's': 
                        if(!isPaused) {
                            softDropActive = true;
                            if(currentPiece && !checkCollision(currentPiece,board,0,1)){
                                currentPiece.y++;
                                score+=1; 
                                if(p5InstanceCache.mainSketch?.millis) lastDropTime = p5InstanceCache.mainSketch.millis();
                                if(p5InstanceCache.mainSketch?.width>0) p5InstanceCache.mainSketch.redraw();
                            } else if (currentPiece && !isGameOver) {
                                lockPiece();
                            }
                        }
                        break; 
                    case'arrowup':case'w':case'x':if(!isPaused)attemptRotation();break; 
                    case' ':if(!isPaused)hardDrop();break; 
                    case'shift':case'c':if(!isPaused)holdCurrentPiece();break;
                    case'p':case'escape':
                        if (document.getElementById('restart-confirm-modal')?.classList.contains('active')) { 
                            setActiveModal(null); 
                            if (isGameStarted && !isGameOver) {
                                if (!wasPausedBeforeConfirm && p5InstanceCache.mainSketch?.width > 0) {
                                   p5InstanceCache.mainSketch.loop(); 
                                } else if (wasPausedBeforeConfirm && p5InstanceCache.mainSketch?.width > 0) {
                                    // If it was paused before confirm, keep it paused (noLoop) but redraw for state.
                                    p5InstanceCache.mainSketch.redraw();
                                    p5InstanceCache.mainSketch.noLoop();
                                }
                            }
                        }
                        else if (document.getElementById('start-modal')?.classList.contains('active') || document.getElementById('game-over-modal')?.classList.contains('active')) {
                            // Do nothing special for Esc on these modals, let Enter handle actions
                        }
                        else { togglePause(); }
                        break;
                    case'enter':
                        if(document.getElementById('start-modal')?.classList.contains('active'))initGame();
                        else if(document.getElementById('game-over-modal')?.classList.contains('active')){ setActiveModal(null); initGame(); } 
                        else if(document.getElementById('pause-modal')?.classList.contains('active'))togglePause();
                        else if(document.getElementById('restart-confirm-modal')?.classList.contains('active')){document.getElementById('confirm-restart-button').click();} 
                        break;
                }
            });
            document.addEventListener('keyup',(e)=>{
                if(e.key.toLowerCase()==='arrowdown'||e.key.toLowerCase()==='s') softDropActive = false;
            });
            
            const btnMap=[
                {id:'start-game-button',action:initGame},
                {id:'pause-button',action:togglePause},
                {id:'resume-button',action:togglePause},
                {id:'restart-button-gameover',action: () => {setActiveModal(null); initGame();} }, 
                {id:'new-game-button',action: handleRestartRequest },
                {id:'confirm-restart-button', action: () => {
                    setActiveModal(null); 
                    initGame(); 
                }},
                {id:'cancel-restart-button', action: () => {
                    setActiveModal(null);
                    if (isGameStarted && !isGameOver) { 
                        if (!wasPausedBeforeConfirm && p5InstanceCache.mainSketch?.width > 0) {
                            p5InstanceCache.mainSketch.loop(); 
                        } else if (wasPausedBeforeConfirm && p5InstanceCache.mainSketch?.width > 0) {
                            // If it was paused, ensure it remains paused visually
                            setActiveModal('pause-modal'); // Re-show pause modal if it was paused
                            p5InstanceCache.mainSketch.redraw(); // Redraw to show current state
                            p5InstanceCache.mainSketch.noLoop(); // Keep it noLoop
                        }
                    }
                }}
            ];
            btnMap.forEach(i=>{const b=document.getElementById(i.id);if(b)b.addEventListener('click',i.action);else console.warn(`Button ID '${i.id}' not found.`);});
            
            let rT;window.addEventListener('resize',()=>{clearTimeout(rT);rT=setTimeout(()=>{if(p5InstanceCache.mainSketch?.canvas)p5InstanceCache.mainSketch.windowResized();const nC=document.getElementById('next-piece-canvas-container');if(p5InstanceCache.nextPieceSketch?.canvas&&nC?.clientWidth>0){p5InstanceCache.nextPieceSketch.resizeCanvas(nC.clientWidth,nC.clientHeight);p5InstanceCache.nextPieceSketch.setup();p5InstanceCache.nextPieceSketch.redraw();}const hC=document.getElementById('hold-piece-canvas-container');if(p5InstanceCache.holdPieceSketch?.canvas&&hC?.clientWidth>0){p5InstanceCache.holdPieceSketch.resizeCanvas(hC.clientWidth,hC.clientHeight);p5InstanceCache.holdPieceSketch.setup();p5InstanceCache.holdPieceSketch.redraw();}},160);});
        });
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>
</body>
</html>
